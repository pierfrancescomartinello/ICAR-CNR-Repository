# -*- coding: utf-8 -*-
"""server.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1y3044P1TNKBb81PjJp7BfuMbs7yE3TiO
"""
"""
!pip -q install pyngrok
!ngrok config add-authtoken 2es5nf06I3UZtEobPxyiIkF8YEK_7P8HwXtAaTnFHo6GRLgtC
!pip install -q diffusers
!git clone https://github.com/openai/shap-e.git; cd shap-e/; pip -q install -e .
"""

import torch

from shap_e.diffusion.sample import sample_latents
from shap_e.diffusion.gaussian_diffusion import diffusion_from_config
from shap_e.models.download import load_model, load_config
from shap_e.util.notebooks import create_pan_cameras, decode_latent_images, decode_latent_mesh
from diffusers.utils import export_to_gif

import os
import threading
import time
from urllib import parse
from typing import List
import shutil
import glob

from flask import Flask, request, jsonify, Response, send_from_directory
from pyngrok import ngrok, conf

# Setup stuff for shap-e

device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
# print(torch.cuda.is_available())
xm = load_model('transmitter', device=device)
model = load_model('text300M', device=device)
diffusion = diffusion_from_config(load_config('diffusion'))
size = 128
cameras = create_pan_cameras(size, device)
render_mode = 'nerf'



guidance_scale = 15.0

def cache_purge():
    global cache_dir
    cache_dir = os.getcwd() +"/cache/"
    if os.path.exists(cache_dir):
        shutil.rmtree(cache_dir)

    os.mkdir(cache_dir)



def cache_update(models, query, cli_id):
    # if the cache folder exists, purge it.
    if os.path.isdir(cache_dir + f"{cli_id}/{query}/"):
        shutil.rmtree(cache_dir + f"{cli_id}/{query}/")
    os.mkdir(cache_dir + f"{cli_id}/{query}/")

    # return the output of the model as a series of images -> useful for the gif function.
    gif_files = [decode_latent_images(xm, i, cameras, rendering_mode = render_mode) for i in models]
    os.mkdir(cache_dir + f"{cli_id}/{query}/gifs/")
    os.mkdir(cache_dir + f"{cli_id}/{query}/meshes/")

    for index, img in enumerate(models):

        export_to_gif(gif_files[index],f"{cache_dir}{cli_id}/{query}/gifs/{index}_model.gif")

        t = decode_latent_mesh(xm, img).tri_mesh()
        with open(f'{cache_dir}{cli_id}/{query}/meshes/{index}_mesh.obj', 'w') as f:
            t.write_obj(f)

    gifs = glob.glob(f"{cache_dir}{cli_id}/{query}/gifs/*.gif")

    shutil.make_archive(f"{cache_dir}{cli_id}/{query}/output", "zip", f"{cache_dir}{cli_id}/{query}/gifs/")

    shutil.rmtree(f"{cache_dir}{cli_id}/{query}/gifs/")




def query_inference(prompt:str, tentatives:int):
    images = sample_latents(
        batch_size=tentatives,
        model=model,
        diffusion=diffusion,
        guidance_scale=guidance_scale,
        model_kwargs=dict(texts=[prompt] * tentatives),
        progress=True,
        clip_denoised=True,
        use_fp16=True,
        use_karras=True,
        karras_steps=64,
        sigma_min=1e-3,
        sigma_max=160,
        s_churn=0,
    )
    return images

# Setup for flask
app = Flask(__name__)
port = "5000"
cache_dir = os.getcwd() + "/cache/"
if os.path.isdir(cache_dir) and len(os.listdir(cache_dir)) != 0:

    shutil.rmtree(cache_dir)
    os.mkdir(cache_dir)


conf.get_default().authtoken = "2es5nf06I3UZtEobPxyiIkF8YEK_7P8HwXtAaTnFHo6GRLgtC"

# Open a ngrok tunnel to the HTTP server
public_url = ngrok.connect(port).public_url

# Update any base URLs to use the public ngrok URL
app.config["BASE_URL"] = public_url


clients = dict()
cache_purge()
print(f"{public_url}")

#___________________________________________
# Debug Method - Unimportant
@app.route("/", methods=["GET"])
def home():
    return "", 200


@app.route("/auth", methods=["POST"])
def authorization():
    # Authorize a new client. Accessible using <url>/auth?cli_id=<id>
    cli_id = request.args["cli_id"]
    if cli_id in clients:
        # Already authorized
        return '', 401 # Unauthorized
    else:
        clients[cli_id] = time.time()
        os.mkdir(cache_dir + f"/{cli_id}/")
        return '', 200 # OK

@app.route("/query", methods = ["GET"])
def pictures_exchange():
    cli_id = request.args["cli_id"]
    if cli_id not in clients:
        return '', 401 # Unauthorized
    query = parse.unquote(request.args["query"])
    print(query)
    tentatives = int(parse.unquote(request.args["tentatives"]))
    # Ask for query
    models = query_inference(query, tentatives)
    cache_update(models, query, cli_id)

    return send_from_directory(f"{cache_dir}/{cli_id}/{query}/","output.zip")


@app.route("/download", methods=["GET"])
def download():
    print("Download?")
    cli_id = request.args["cli_id"]
    if cli_id not in clients:
        return '', 401 #
    input(cli_id in clients)
    query = parse.unquote(request.args["query"])
    print(query)
    obj_num = int(parse.unquote(request.args["object"]))
    print(obj_num)

    if os.path.exists(f'{cache_dir}{cli_id}/{query}/meshes/{obj_num}_mesh.obj'):
        file_data = ""
        with open(f'{cache_dir}{cli_id}/{query}/meshes/{obj_num}_mesh.obj' , "rb") as f:
            file_data = f.read()

        response = Response(file_data, mimetype = "text/plain")
        response.headers.set('Content-Disposition', 'attachment', filename=f"{obj_num}_mesh.obj")

        return response


        # return send_from_directory(f"{cache_dir}/{cli_id}/{query}/","output.zip")
        # return send_from_directory(f'{cache_dir}{cli_id}/{query}/meshes/{obj_num}_mesh.ply', f"{query}.ply", as_attachment = True)
    else:
        print("WAA")
        return "The resource does not exists", 418

app.run(debug = False, threaded=False, use_reloader = False)

# Use Threads?
#threading.Thread(target=app.run, kwargs={"use_reloader": False}).start()
